"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.IgnoreFiles = exports.allBlockedFilesRegex = exports.allBlockedFiles = exports.blockedFiles = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
exports.blockedFiles = {
    common: [".git", ".vscode", ".cache"],
    go: [],
    js: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
    py: ["venv"],
    rb: ["Gemfile.lock"],
    rs: ["Cargo.lock", "target"],
    ts: ["node_modules", "package-lock.json", "yarn.lock", ".npm"],
};
exports.allBlockedFiles = [...new Set(Object.values(exports.blockedFiles).flat())];
exports.allBlockedFilesRegex = RegExp(`(${exports.allBlockedFiles.join("|")})$`.replace(/\./g, "\\."), "i");
class IgnoreFiles {
    fileName;
    files = [];
    globPattern;
    list = [];
    path;
    constructor(options) {
        this.path = this.#normalizePath(options.path);
        this.fileName = options.fileName;
        this.globPattern = options.globPattern ?? true;
        if (this.fileName && this.path)
            this.files = this.#findIgnoreFiles(this.fileName, this.path);
        options.optionalIgnoreList ??= [];
        this.list = options.optionalIgnoreList.concat(this.#getIgnoreList());
        if (this.globPattern)
            this.list = this.list.flatMap(a => [a, `${a}/**`, `**/${a}`, `**/${a}/**`, `${this.path}/${a}`, `${this.path}/${a}/**`]);
    }
    #findIgnoreFiles(fileName, path) {
        return this.#recursivelyReadDirSync(path)
            .filter(file => file.endsWith(fileName) && (0, node_fs_1.statSync)(file).isFile());
    }
    #getIgnoreList() {
        return this.#resolveIgnoreFile(this.files);
    }
    #normalizePath(path) {
        return path.replace(/\\/g, "/");
    }
    #resolveIgnoreFile(ignoreFile) {
        if (Array.isArray(ignoreFile)) {
            const ignored = [];
            for (let i = 0; i < ignoreFile.length; i++)
                ignored.push(...this.#resolveIgnoreFile(ignoreFile[i]));
            return ignored;
        }
        if (ignoreFile)
            if ((0, node_fs_1.existsSync)(ignoreFile))
                if ((0, node_fs_1.statSync)(ignoreFile).isFile())
                    return (0, node_fs_1.readFileSync)(ignoreFile, "utf8")
                        .replace(/#[^\r?\n]+/g, "")
                        .split(/\r?\n/)
                        .filter(a => a);
        return [];
    }
    #recursivelyReadDirSync(path) {
        if (!(0, node_fs_1.existsSync)(path))
            return [];
        if ((0, node_fs_1.statSync)(path).isFile())
            path = (0, node_path_1.dirname)(path);
        const files = (0, node_fs_1.readdirSync)(this.#normalizePath(path), { withFileTypes: true });
        const cache = [];
        for (const file of files) {
            const fileOrDir = (0, node_path_1.join)(path, file.name);
            if (file.isDirectory()) {
                if (exports.allBlockedFilesRegex.test(fileOrDir))
                    continue;
                cache.push(...this.#recursivelyReadDirSync(fileOrDir));
            }
            else {
                cache.push(fileOrDir);
            }
        }
        return cache;
    }
}
exports.IgnoreFiles = IgnoreFiles;
