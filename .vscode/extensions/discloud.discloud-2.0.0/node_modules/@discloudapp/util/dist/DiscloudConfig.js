"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DiscloudConfig = exports.discloudConfigRequiredScopes = void 0;
const node_fs_1 = require("node:fs");
const node_path_1 = require("node:path");
exports.discloudConfigRequiredScopes = {
    bot: ["MAIN", "NAME", "TYPE", "RAM", "VERSION"],
    site: ["ID", "MAIN", "TYPE", "RAM", "VERSION"],
};
class DiscloudConfig {
    path;
    constructor(path) {
        this.path = path;
        if (this.path.endsWith("discloud.config"))
            if (this.exists && (0, node_fs_1.statSync)(this.path).isFile())
                return;
        if (this.exists && (0, node_fs_1.statSync)(this.path).isFile())
            this.path = (0, node_path_1.dirname)(this.path);
        this.path = (0, node_path_1.join)(path, "discloud.config");
    }
    get comments() {
        if (this.exists)
            return (0, node_fs_1.readFileSync)(this.path, "utf8").split(/\r?\n/).filter(a => /^\s*#/.test(a));
        return [];
    }
    get data() {
        if (this.exists)
            return this.#configToObj((0, node_fs_1.readFileSync)(this.path, "utf8"));
        return {};
    }
    get exists() {
        return (0, node_fs_1.existsSync)(this.path);
    }
    get existsMain() {
        if (this.data.MAIN)
            return (0, node_fs_1.existsSync)(this.data.MAIN);
    }
    get fileExt() {
        return this.data.MAIN?.split(".").pop();
    }
    get missingProps() {
        return this.#requiredProps.filter(key => !this.data[key]);
    }
    get #requiredProps() {
        return exports.discloudConfigRequiredScopes[this.data.TYPE] ?? Object.values(exports.discloudConfigRequiredScopes).flat();
    }
    #objToString(obj) {
        if (typeof obj === "undefined" || obj === null)
            return "";
        if (typeof obj === "function")
            return this.#configToObj(obj());
        if (!obj)
            return `${obj}`;
        const result = [];
        if (typeof obj === "object") {
            if (Array.isArray(obj)) {
                for (const value of obj)
                    result.push(this.#objToString(value));
            }
            else {
                const keys = Object.keys(obj);
                for (const key of keys)
                    result.push(`${key}=${this.#objToString(obj[key])}`);
            }
        }
        else {
            result.push(obj);
        }
        return result.join("\n");
    }
    #configToObj(s) {
        if (typeof s !== "string")
            return {};
        return this.#processValues(Object.fromEntries(s
            .split(/\r?\n/)
            .filter(a => !/^\s*#/.test(a))
            .filter(a => a)
            .map(a => a.split("="))));
    }
    #processValues(obj) {
        if (!obj)
            return obj;
        const keys = Object.keys(obj);
        for (const key of keys) {
            if (["APT", "AVATAR", "ID", "MAIN", "NAME", "TYPE", "VERSION"].includes(key))
                continue;
            const value = obj[key];
            if (!isNaN(Number(value))) {
                obj[key] = Number(value);
                continue;
            }
            if (["true", "false"].includes(obj[key])) {
                obj[key] = value == "true";
                continue;
            }
        }
        return obj;
    }
    get(key) {
        return this.data[key];
    }
    set(key, value) {
        this.update({ [key]: value });
    }
    update(save, comments = this.comments) {
        save = { ...this.data, ...save };
        try {
            (0, node_fs_1.writeFileSync)(this.path, this.#objToString([comments, save]), "utf8");
        }
        catch (error) {
            return error;
        }
    }
}
exports.DiscloudConfig = DiscloudConfig;
